{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Sheet Detail</title>
    <link href="{% static 'HelloMusicApp/css/sheet.css' %}" rel="stylesheet" />
    <script src="{% static 'HelloMusicApp/js/vexflow.js' %}"></script>
    <script src="{% static 'HelloMusicApp/js/Tone.js' %}"></script>
  </head>
  <body>
    <div class="container">
      <div class="controls">
        <div class="control-group">
          <label for="clef-select">Select Clef:</label>
          <select id="clef-select">
            <option value="treble">Treble Clef</option>
            <option value="bass">Bass Clef</option>
          </select>
        </div>

        <div class="control-group">
          <label for="time-select">Time Signature:</label>
          <select id="time-select">
            <option value="4/4">4/4</option>
            <option value="3/4">3/4</option>
            <option value="2/4">2/4</option>
            <option value="6/8">6/8</option>
          </select>
        </div>

        <button id="apply-changes">Apply Changes</button>
        <button id="clear-notes">Clear Notes</button>

        <div class="control-group" style="margin-top:20px;">
          <label for="key-signature">Key Signature:</label>
          <select id="key-signature">
              <option value="C">C Major</option>
              <option value="G">G Major</option>
              <option value="D">D Major</option>
              <option value="A">A Major</option>
              <option value="E">E Major</option>
              <option value="F">F Major</option>
              <option value="Bb">B♭ Major</option>
              <option value="Eb">E♭ Major</option>
          </select>
        </div>

        {% comment %} <div class="accidental-controls">
            <button class="accidental-btn" data-accidental="sharp" title="Sharp">♯</button>
            <button class="accidental-btn" data-accidental="flat" title="Flat">♭</button>
            <button class="accidental-btn" data-accidental="natural" title="Natural">♮</button>
        </div>

        <div class="articulation-controls">
            <button class="articulation-btn" data-articulation="staccato" title="Staccato">·</button>
            <button class="articulation-btn" data-articulation="legato" title="Legato">‿</button>
            <button class="articulation-btn" data-articulation="accent" title="Accent">></button>
        </div> {% endcomment %}

        <div class="separator"></div>

        <h2>Note Palette</h2>
            <div class="draggable-note" draggable="true" data-duration="w" title="Whole Note">
              &#119133;
            </div>
            <div class="draggable-note" draggable="true" data-duration="h" title="Half Note">
              &#119134;
            </div>
            <div class="draggable-note" draggable="true" data-duration="q" title="Quarter Note">
              &#119135;
            </div>
            <div class="draggable-note" draggable="true" data-duration="8" title="Eighth Note">
              &#119136;
            </div>
            <div class="draggable-note" draggable="true" data-duration="16" title="Sixteenth Note">
              &#119137;
            </div>
            {% comment %} <div class="draggable-note" draggable="true" data-duration="qd" title="Dotted Quarter Note">
                Dotted Quarter
            </div>
            <div class="draggable-note" draggable="true" data-duration="8t" title="Eighth Note Triplet">
                Triplet
            </div> {% endcomment %}

            {% comment %} <h2>Rests</h2>
            <div class="draggable-note" draggable="true" data-duration="wr" title="Whole Rest">
                Whole Rest
            </div>
            <div class="draggable-note" draggable="true" data-duration="hr" title="Half Rest">
                Half Rest
            </div>
            <div class="draggable-note" draggable="true" data-duration="qr" title="Quarter Rest">
                Quarter Rest
            </div>
            <div class="draggable-note" draggable="true" data-duration="8r" title="Eighth Rest">
                Eighth Rest
            </div> {% endcomment %}

            <div class="history-controls">
                <button id="undo" title="Undo last action">Undo</button>
                <button id="redo" title="Redo last action">Redo</button>
            </div>

        <div class="playback-controls">
          <button id="play">Play</button>
          <button id="stop">Stop</button>
        </div>

        <div id="error-message"></div>
      </div>
      <div class="staff-scroll-container">
        <div id="staff-container"></div>
      </div>
    </div>

    <script>
      const { Factory, Renderer, Stave, Voice, Formatter } = Vex.Flow;

      // Initialize music state
      let measures = [[]];
      let currentMeasureIndex = 0;
      let selectedNote = null;
      let synth = null;
      let isPlaying = false;
      let audioInitialized = false;
      let draggedDuration = null;
      let staffLineHighlight = null;
      let staffSpaceHighlight = null;

      // Duration mappings
      const DURATIONS = {
        "w": { ticks: 4096, beats: 4, time: "1n" },    // Whole note
        "h": { ticks: 2048, beats: 2, time: "2n" },    // Half note
        "q": { ticks: 1024, beats: 1, time: "4n" },    // Quarter note
        "8": { ticks: 512, beats: 0.5, time: "8n" },   // Eighth note
        "16": { ticks: 256, beats: 0.25, time: "16n" }, // Sixteenth note
        "wr": { ticks: 4096, beats: 4, time: "1n" },   // Whole rest
        "hr": { ticks: 2048, beats: 2, time: "2n" },   // Half rest
        "qr": { ticks: 1024, beats: 1, time: "4n" },   // Quarter rest
        "8r": { ticks: 512, beats: 0.5, time: "8n" },  // Eighth rest
        "16r": { ticks: 256, beats: 0.25, time: "16n" } // Sixteenth rest
    };

      // Note frequency mappings
      const NOTE_FREQUENCIES = {
        c: 261.63,
        d: 293.66,
        e: 329.63,
        f: 349.23,
        g: 392.0,
        a: 440.0,
        b: 493.88,
      };

      // History management
      const history = {
        undoStack: [],
        redoStack: [],
        
        pushState() {
            // Convert measures to a serializable format
            const serializableMeasures = measures.map(measure => 
                measure.map(note => ({
                    keys: note.keys,
                    duration: note.duration,
                    accidental: note.modifiers.find(m => m instanceof Vex.Flow.Accidental)?.type,
                    articulation: note.modifiers.find(m => m instanceof Vex.Flow.Articulation)?.type,
                    tied: note.tied,
                    tieStart: note.tieStart
                }))
            );
            
            this.undoStack.push(JSON.stringify(serializableMeasures));
            this.redoStack = [];
            if (this.undoStack.length > 50) this.undoStack.shift();
        },
        
        undo() {
            if (this.undoStack.length > 0) {
                const currentState = this.serializeMeasures(measures);
                this.redoStack.push(currentState);
                const previousState = JSON.parse(this.undoStack.pop());
                measures = this.deserializeMeasures(previousState);
                initializeStaves();
            }
        },
        
        redo() {
            if (this.redoStack.length > 0) {
                const currentState = this.serializeMeasures(measures);
                this.undoStack.push(currentState);
                const nextState = JSON.parse(this.redoStack.pop());
                measures = this.deserializeMeasures(nextState);
                initializeStaves();
            }
        },
        
        serializeMeasures(measures) {
            const serializableMeasures = measures.map(measure => 
                measure.map(note => ({
                    keys: note.keys,
                    duration: note.duration,
                    accidental: note.modifiers.find(m => m instanceof Vex.Flow.Accidental)?.type,
                    articulation: note.modifiers.find(m => m instanceof Vex.Flow.Articulation)?.type,
                    tied: note.tied,
                    tieStart: note.tieStart
                }))
            );
            return JSON.stringify(serializableMeasures);
        },
        
        deserializeMeasures(serializedMeasures) {
            return serializedMeasures.map(measure =>
                measure.map(noteData => {
                    const note = new Vex.Flow.StaveNote({
                        keys: noteData.keys,
                        duration: noteData.duration
                    });
                    
                    if (noteData.accidental) {
                        note.addAccidental(0, new Vex.Flow.Accidental(noteData.accidental));
                    }
                    
                    if (noteData.articulation) {
                        note.addArticulation(0, new Vex.Flow.Articulation(noteData.articulation));
                    }
                    
                    note.tied = noteData.tied;
                    note.tieStart = noteData.tieStart;
                    
                    return note;
                })
            );
        }
      };

      // Initialize Tone.js
      async function initAudio() {
        try {
          await Tone.start();
          console.log('Audio is ready');
          
          if (!synth) {
              synth = new Tone.Synth().toDestination();
          }
          audioInitialized = true;
          return true;
        } catch (error) {
            console.error('Failed to initialize audio:', error);
            return false;
        }
      }

      // Initialize VexFlow for each measure
      function initializeStaves() {
        const staffContainer = document.getElementById('staff-container');
        staffContainer.innerHTML = '';
        
        /*
        // Ensure at least one measure exists
        if (measures.length === 0) {
            measures = [[]];
        }
        
        const numberOfRows = Math.ceil(measures.length / 4);
        const MEASURE_WIDTH = 300;
        const TOTAL_WIDTH = MEASURE_WIDTH * 4 + 50;
        
        for (let row = 0; row < numberOfRows; row++) {
            const div = document.createElement('div');
            div.className = 'staff-row';
            div.id = `staff-row-${row}`;
            staffContainer.appendChild(div);
    
            const renderer = new Vex.Flow.Renderer(div, Vex.Flow.Renderer.Backends.SVG);
            renderer.resize(TOTAL_WIDTH, 150);
            const context = renderer.getContext();
            
            const startMeasure = row * 4;
            const endMeasure = Math.min((row + 1) * 4, measures.length);
            
            for (let i = startMeasure; i < endMeasure; i++) {
                const xOffset = (i % 4) * MEASURE_WIDTH + 10;
                const stave = new Vex.Flow.Stave(xOffset, 40, MEASURE_WIDTH);
                
                if (i === startMeasure) {
                    const clef = document.getElementById('clef-select').value;
                    stave.addClef(clef);
                    const keySignature = document.getElementById('key-signature').value;
                    stave.addKeySignature(keySignature);
                    if (row === 0) {
                        const timeSignature = document.getElementById('time-select').value;
                        stave.addTimeSignature(timeSignature);
                    }
                }
                
                stave.setContext(context).draw();
                drawMeasure(measures[i], stave, context);
            }
        }
        */
        // Calculate total rows needed
        const measuresPerRow = 4;
        const totalRows = Math.ceil(measures.length / measuresPerRow);
        
        for (let row = 0; row < totalRows; row++) {
            const div = document.createElement('div');
            div.className = 'staff-row';
            div.id = `staff-row-${row}`;
            staffContainer.appendChild(div);
            
            const renderer = new Vex.Flow.Renderer(div, Vex.Flow.Renderer.Backends.SVG);
            renderer.resize(1250, 150); // Width to accommodate 4 measures
            const context = renderer.getContext();
            
            // Draw measures for this row
            for (let i = 0; i < measuresPerRow; i++) {
                const measureIndex = row * measuresPerRow + i;
                const xOffset = i * 300 + 10;
                
                const stave = new Vex.Flow.Stave(xOffset, 40, 300);
                
                // Add clef and key signature to first measure of each row
                if (i === 0) {
                    const clef = document.getElementById('clef-select').value;
                    stave.addClef(clef);
                    const keySignature = document.getElementById('key-signature').value;
                    stave.addKeySignature(keySignature);
                    if (row === 0) {
                        const timeSignature = document.getElementById('time-select').value;
                        stave.addTimeSignature(timeSignature);
                    }
                }
                
                stave.setContext(context).draw();
                
                // Draw measure content if it exists
                if (measureIndex < measures.length) {
                    drawMeasure(measures[measureIndex], stave, context);
                }
            }
        }

      }

      // Initialize preview system
      function initializePreviewSystem() {
        createHighlightElements();
    
        // Add drag event listeners to draggable notes
        document.querySelectorAll('.draggable-note').forEach(note => {
            note.addEventListener('dragstart', handleDragStart);
            note.addEventListener('dragend', handleDragEnd);
        });
    
        // Add drag event listeners to staff container
        const staffContainer = document.querySelector('.staff-scroll-container');
        
        // Remove any existing listeners
        staffContainer.removeEventListener('dragover', handleDragOver);
        staffContainer.removeEventListener('dragleave', handleDragLeave);
        staffContainer.removeEventListener('drop', handleDrop);
        
        // Add fresh listeners
        staffContainer.addEventListener('dragover', handleDragOver);
        staffContainer.addEventListener('dragleave', handleDragLeave);
        staffContainer.addEventListener('drop', handleDrop);
      }

      function getTimeSignature() {
        const timeSig = document.getElementById("time-select").value;
        const [num, den] = timeSig.split("/").map(Number);
        return { num, den };
      }

      // Add getCurrentBeats function if not already present
      function getCurrentBeats(measureIndex) {
        if (!measures[measureIndex]) return 0;
        
        return measures[measureIndex].reduce((sum, note) => {
            const duration = note.duration.split("r")[0]; // Remove 'r' from rest durations
            return sum + (DURATIONS[duration]?.beats || 0);
        }, 0);
      }

      function getAccidentalSymbol(type) {
        const accidentalMap = {
            'sharp': '#',
            'flat': 'b',
            'natural': 'n'
        };
        return accidentalMap[type] || '#';
      }

      function getArticulationSymbol(type) {
        const articulationMap = {
            'staccato': 'a.',
            'legato': 'a-',
            'accent': 'a>'
        };
        return articulationMap[type] || 'a.';
      }

      // Add getCurrentTicks function
      function getCurrentTicks(measureIndex) {
        if (!measures[measureIndex]) return 0;
        
        return measures[measureIndex].reduce((sum, note) => {
            const duration = note.duration.split("r")[0];
            return sum + (DURATIONS[duration]?.ticks || 0);
        }, 0);
      }

      // Helper function to get appropriate duration for beats
      function getDurationForBeats(beats) {
        if (beats === 4) return 'w';
        if (beats === 2) return 'h';
        if (beats === 1) return 'q';
        if (beats === 0.5) return '8';
        if (beats === 0.25) return '16';
        return 'q'; // default
      }

      // Function to get note name based on staff position
      function getNoteNameFromPosition(lineIndex, clef) {
        // Define valid positions and notes for each clef - ordered from bottom to top
        const treblePositions = {
            10: { note: "c/4", type: "line" },    // Ledger line C4
            9: { note: "d/4", type: "space" },    // Space between ledger and staff
            8: { note: "e/4", type: "line" },     // Bottom line
            7: { note: "f/4", type: "space" },
            6: { note: "g/4", type: "line" },
            5: { note: "a/4", type: "space" },
            4: { note: "b/4", type: "line" },
            3: { note: "c/5", type: "space" },
            2: { note: "d/5", type: "line" },
            1: { note: "e/5", type: "space" },
            0: { note: "f/5", type: "line" },
            "-1": { note: "g/5", type: "space" },   // Space above staff
            "-2": { note: "a/5", type: "line" }     // Ledger line above
        };
    
        const bassPositions = {
            10: { note: "e/2", type: "line" },    // Ledger line
            9: { note: "f/2", type: "space" },    // Space between ledger and staff
            8: { note: "g/2", type: "line" },     // Bottom line
            7: { note: "a/2", type: "space" },
            6: { note: "b/2", type: "line" },
            5: { note: "c/3", type: "space" },
            4: { note: "d/3", type: "line" },
            3: { note: "e/3", type: "space" },
            2: { note: "f/3", type: "line" },
            1: { note: "g/3", type: "space" },
            0: { note: "a/3", type: "line" },
            "-1": { note: "b/3", type: "space" },   // Space above staff
            "-2": { note: "c/4", type: "line" }     // Ledger line above
        };
    
        const positions = clef === "treble" ? treblePositions : bassPositions;
        return positions[lineIndex] || null;
      }

      function fillWithRests(voice, measureNotes, totalTicks) {
        // Calculate current ticks in the measure
        const currentTicks = measureNotes.reduce((sum, note) => {
            const duration = note.duration.split("r")[0];
            return sum + (DURATIONS[duration]?.ticks || 0);
        }, 0);
    
        let remainingTicks = totalTicks - currentTicks;
        
        // Add rests to fill the remaining time
        while (remainingTicks > 0) {
            let restDuration;
            // More precise rest duration selection
            if (remainingTicks >= 4096 && remainingTicks >= totalTicks/2) restDuration = "wr";
            else if (remainingTicks >= 2048 && remainingTicks >= totalTicks/4) restDuration = "hr";
            else if (remainingTicks >= 1024) restDuration = "qr";
            else if (remainingTicks >= 512) restDuration = "8r";
            else if (remainingTicks >= 256) restDuration = "16r";
            else break; // Prevent adding rests smaller than 16th notes
    
            const rest = new Vex.Flow.StaveNote({
                keys: ["b/4"],
                duration: restDuration
            });
            
            const restTicks = DURATIONS[restDuration.slice(0, -1)].ticks;
            if (restTicks <= remainingTicks) {
                try {
                    voice.addTickable(rest);
                    remainingTicks -= restTicks;
                } catch (error) {
                    console.error('Error adding rest:', error);
                    break;
                }
            } else {
                break;
            }
        }
      }

      // Helper function to create note object
      function createNote(duration, lineIndex, clef) {
        // Get position info
        const positionInfo = getNoteNameFromPosition(lineIndex, clef);
        
        if (!positionInfo) {
            return null;
        }

        // Create the note with the correct pitch
        const note = new Vex.Flow.StaveNote({
            keys: [positionInfo.note],
            duration: duration,
            auto_stem: true
        });
        
        return note;
      }

      function addNote(duration, x, y, measureIndex) {
        const rowHeight = 210; // Match the height used in handleDragOver
        const rowIndex = Math.floor(y / rowHeight);
        const staffTop = 100 + (rowHeight * rowIndex);
        const staffLineSpacing = 5;
        const relativeY = y - staffTop;
        const lineIndex = Math.round(relativeY / staffLineSpacing);
        
        // Ensure valid range includes ledger lines
        if (lineIndex >= -2 && lineIndex <= 10) {
          const clef = document.getElementById('clef-select').value;
          const note = createNote(duration, lineIndex, clef);

          const { num, den } = getTimeSignature();
          
          // Calculate total ticks for the measure
          const totalTicks = 4096 * (num / den);
          
          // Calculate current ticks in the measure
          const currentTicks = getCurrentTicks(measureIndex);
          const noteTicks = DURATIONS[duration]?.ticks || 0;
          
          // Ensure measures array exists up to this index
          while (measures.length <= measureIndex) {
              measures.push([]);
          }
          
          // Check if note fits in current measure
          if (currentTicks + noteTicks > totalTicks) {
              // Note doesn't fit, create new measure if needed
              const nextMeasureIndex = measureIndex + 1;
              while (measures.length <= nextMeasureIndex) {
                  measures.push([]);
              }
              //measures[nextMeasureIndex].push(note);
              measures[nextMeasureIndex].unshift(note);
          } else {
              // Note fits in current measure
              measures[measureIndex].push(note);
          }
          
          history.pushState();
          initializeStaves();
        }
      }

      function drawMeasure(measureNotes, stave, context) {
        const { num, den } = getTimeSignature();
        const totalTicks = (num / den) * 4096;
        
        const voice = new Vex.Flow.Voice({
            num_beats: num,
            beat_value: den,
            resolution: Vex.Flow.RESOLUTION
        }).setMode(Vex.Flow.Voice.Mode.SOFT);  // Add SOFT mode for more forgiving timing
    
        if (!measureNotes || measureNotes.length === 0) {
            // For empty measures, add a whole rest
            const rest = new Vex.Flow.StaveNote({
                keys: ["b/4"],
                duration: "wr"
            });
            voice.addTickable(rest);
        } else {
            let currentTicks = 0;
            
            // First pass: validate and add notes
            for (let note of measureNotes) {
                const duration = note.duration.split("r")[0];
                const noteTicks = DURATIONS[duration]?.ticks || 0;
                
                if (currentTicks + noteTicks <= totalTicks) {
                    voice.addTickable(note);
                    currentTicks += noteTicks;
                }
            }
            
            // Only add rests if there's space
            if (currentTicks < totalTicks) {
                let remainingTicks = totalTicks - currentTicks;
                
                while (remainingTicks >= 256) { // Minimum 16th note rest
                    let restDuration;
                    if (remainingTicks >= 4096 && remainingTicks >= totalTicks/2) restDuration = "wr";
                    else if (remainingTicks >= 2048 && remainingTicks >= totalTicks/4) restDuration = "hr";
                    else if (remainingTicks >= 1024) restDuration = "qr";
                    else if (remainingTicks >= 512) restDuration = "8r";
                    else restDuration = "16r";
                    
                    const restTicks = DURATIONS[restDuration.slice(0, -1)].ticks;
                    if (restTicks <= remainingTicks) {
                        const rest = new Vex.Flow.StaveNote({
                            keys: ["b/4"],
                            duration: restDuration
                        });
                        voice.addTickable(rest);
                        remainingTicks -= restTicks;
                    } else {
                        break;
                    }
                }
            }
        }
    
        const formatter = new Vex.Flow.Formatter();
        try {
            formatter.joinVoices([voice]).format([voice], stave.getWidth() - 50);
            voice.draw(context, stave);
        } catch (error) {
            console.error('Formatting error:', error);
        }
      }
      
      async function playMeasures() {
        if (!synth || !audioInitialized) {
            console.log('Audio not initialized');
            return;
        }
    
        try {
            // Ensure audio context is in running state
            if (Tone.context.state !== 'running') {
                await Tone.context.resume();
            }
    
            isPlaying = true;
            const tempo = 120;
            const beatDuration = 60 / tempo;
    
            for (let measureIndex = 0; measureIndex < measures.length && isPlaying; measureIndex++) {
                const measure = measures[measureIndex];
                for (let noteIndex = 0; noteIndex < measure.length && isPlaying; noteIndex++) {
                    const note = measure[noteIndex];
                    if (!note.duration.includes("r")) {  // Skip rests
                        const noteKey = note.keys[0].split("/")[0];
                        const octave = note.keys[0].split("/")[1];
                        const frequency = NOTE_FREQUENCIES[noteKey.toLowerCase()] * 
                            Math.pow(2, octave - 4);
    
                        // Use Tone.js timing
                        synth.triggerAttackRelease(
                            frequency,
                            DURATIONS[note.duration].time,
                            Tone.now()
                        );
                        
                        // Wait for note duration
                        await new Promise(resolve => 
                            setTimeout(resolve, beatDuration * 1000 * DURATIONS[note.duration].beats)
                        );
                    }
                }
            }
        } catch (error) {
            console.error('Playback error:', error);
            document.getElementById("error-message").textContent = 
                "Error during playback. Please try again.";
        } finally {
            isPlaying = false;
        }
      }

      // Create highlight elements
      function createHighlightElements() {
        // Create staff line highlight
        staffLineHighlight = document.createElement('div');
        staffLineHighlight.className = 'staff-line-highlight';
        staffLineHighlight.style.display = 'none';
        document.querySelector('.staff-scroll-container').appendChild(staffLineHighlight);

        // Create staff space highlight
        staffSpaceHighlight = document.createElement('div');
        staffSpaceHighlight.className = 'staff-space-highlight';
        staffSpaceHighlight.style.display = 'none';
        document.querySelector('.staff-scroll-container').appendChild(staffSpaceHighlight);
      }

      function handleDragStart(e) {
        draggedDuration = e.target.dataset.duration;
        
        // Set drag image to be invisible
        const dragImage = document.createElement('div');
        dragImage.style.opacity = '0';
        document.body.appendChild(dragImage);
        e.dataTransfer.setDragImage(dragImage, 0, 0);
        
        setTimeout(() => dragImage.remove(), 0);
      }
      
      function handleDragEnd() {
        draggedDuration = null;
        staffLineHighlight.style.display = 'none';
        staffSpaceHighlight.style.display = 'none';

        const tooltip = document.querySelector('.position-tooltip');
        if (tooltip) tooltip.style.display = 'none';
      }
      
      function handleDragOver(e) {
        e.preventDefault();
        
        const staffContainer = e.currentTarget;
        const staffRect = staffContainer.getBoundingClientRect();
        const scrollTop = staffContainer.scrollTop;
        const scrollLeft = staffContainer.scrollLeft;
        
        const x = e.clientX - staffRect.left + scrollLeft;
        const y = e.clientY - staffRect.top + scrollTop;
        
        // Calculate row based on y position
        const rowHeight = 210; // Height of each staff row including margin (150px + 60px margin)
        const rowIndex = Math.floor(y / rowHeight);

        // Calculate the staff line/space position
        const staffTop = 100; // Adjust based on your staff position
        const staffLineSpacing = 5; // Distance between staff lines
        const relativeY = y - staffTop;
        const lineIndex = Math.round(relativeY / staffLineSpacing);
        
        // Get clef type
        const clef = document.getElementById('clef-select').value;

        // Get number of measures to determine valid rows
        const totalMeasures = measures.length;
        const totalRows = Math.ceil(totalMeasures / 4);
        const isValidRow = rowIndex < totalRows;

        // Create or update tooltip
        let tooltip = document.querySelector('.position-tooltip');
        if (!tooltip) {
            tooltip = document.createElement('div');
            tooltip.className = 'position-tooltip tooltip';
            document.body.appendChild(tooltip);
        }

        // Only show tooltip if within valid staff range and on a valid row
        if (lineIndex >= -2 && lineIndex <= 10 && isValidRow) {  // Include full range for ledger lines          
        // Get note position info
        const positionInfo = getNoteNameFromPosition(lineIndex, clef);
        
        // Only show tooltip if position is valid
        if (positionInfo) {
            const snapPosition = staffTop + (lineIndex * staffLineSpacing);
            const isOnLine = Math.abs(relativeY - (lineIndex * staffLineSpacing)) < 2;

            // Update tooltip content
            tooltip.textContent = `${positionInfo.note.toUpperCase()} ${positionInfo.type}`;
            tooltip.style.left = `${e.pageX + 10}px`;
            tooltip.style.top = `${e.pageY + 10}px`;
            tooltip.style.display = 'block';
            
            if (positionInfo.type === 'line') {
                staffLineHighlight.style.display = 'block';
                staffLineHighlight.style.top = `${snapPosition}px`;
                staffLineHighlight.style.left = '0';
                staffLineHighlight.style.width = '100%';
                staffSpaceHighlight.style.display = 'none';
            } else {
                staffSpaceHighlight.style.display = 'block';
                staffSpaceHighlight.style.top = `${snapPosition - 4}px`;
                staffSpaceHighlight.style.left = '0';
                staffSpaceHighlight.style.width = '100%';
                staffLineHighlight.style.display = 'none';
            }
          } else {
              // Hide everything if position is invalid
              tooltip.style.display = 'none';
              staffLineHighlight.style.display = 'none';
              staffSpaceHighlight.style.display = 'none';
          }

          ////////// later try to test, if useless then remove
          if (positionInfo) {
            e.currentTarget.classList.add('valid-position');
          } else {
              e.currentTarget.classList.remove('valid-position');
          }
          
        }
      }
      
      function handleDragLeave(e) {
        if (!e.currentTarget.contains(e.relatedTarget)) {
            staffLineHighlight.style.display = 'none';
            staffSpaceHighlight.style.display = 'none';
            
            const tooltip = document.querySelector('.position-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }
      }

      function handleDrop(e) {
        e.preventDefault();
        const duration = e.dataTransfer.getData('text/plain');
        
        // Get the staff container and its properties
        const staffContainer = e.currentTarget;
        const staffRect = staffContainer.getBoundingClientRect();
        
        // Calculate exact position relative to staff
        const staffTop = 40; // Starting Y position of the staff
        const staffLineSpacing = 10; // Space between staff lines

        // Get cursor position relative to staff container
        const scrollLeft = staffContainer.scrollLeft - 30;
        const scrollTop = staffContainer.scrollTop;
        const x = e.clientX - staffRect.left + scrollLeft;
        const y = e.clientY - staffRect.top + scrollTop;

        // Calculate staff line position
        const relativeY = y - staffTop;
        const lineIndex = Math.round(relativeY / staffLineSpacing);
        
        // Calculate measure index considering scroll position
        const measureWidth = 300;
        const measureIndex = Math.floor(x / measureWidth);

        // Validate position is within staff bounds
        if (lineIndex >= -2 && lineIndex <= 11) { // 11 possible positions (5 lines + 4 spaces + 2 ledger lines)
          addNote(duration, x, y, measureIndex);
        }
        
        // Hide highlights after dropping
        staffLineHighlight.style.display = 'none';
        staffSpaceHighlight.style.display = 'none';

        // Clean up tooltip
        const tooltip = document.querySelector('.position-tooltip');
        if (tooltip) {
            tooltip.style.display = 'none';
        }
      }

      // Event Listeners
      document.getElementById("apply-changes").addEventListener("click", () => {
        measures = [[]];
        currentMeasureIndex = 0;
        initializeStaves();
        document.getElementById("error-message").textContent = "";
      });

      document.getElementById("clear-notes").addEventListener("click", () => {
        const confirmation = confirm("Sure to clear all?");

        if(confirmation){
          for(let i = 0; i < measures.length; i++){
            measures[i] = [];
          }
          initializeStaves();
          document.getElementById("error-message").textContent = "";
        }
      });

      document.getElementById("play").addEventListener("click", async () => {
        try {
            // Always try to initialize audio on play click
            if (!audioInitialized) {
                const initialized = await initAudio();
                if (!initialized) {
                    document.getElementById("error-message").textContent = 
                        "Please click play again to start audio playback";
                    return;
                }
            }
            
            // Start playback only if initialization was successful
            if (audioInitialized) {
                document.getElementById("error-message").textContent = "";
                isPlaying = true;
                await playMeasures();
            }
        } catch (error) {
            console.error("Audio playback error:", error);
            document.getElementById("error-message").textContent = 
                "Error playing audio. Please try again.";
        }
      });

      document.getElementById("stop").addEventListener("click", () => {
        isPlaying = false;
        if (synth) {
            synth.triggerRelease();
        }
        document.getElementById("error-message").textContent = "";
      });

      document.getElementById("undo").addEventListener("click", () => history.undo());

      document.getElementById("redo").addEventListener("click", () => history.redo());
      
      document.addEventListener("keydown", (e) => {
        if (e.key === "Delete" || e.key === "Backspace") {
          if (selectedNote) {
            const noteElements = document.querySelectorAll(".vf-stavenote");
            const noteIndex = Array.from(noteElements).indexOf(selectedNote);
            if (noteIndex !== -1) {
              measures[currentMeasureIndex].splice(noteIndex, 1);
              selectedNote = null;
              initializeStaves();
            }
          }
        }
      });

      document.querySelectorAll(".draggable-note").forEach((note) => {
        note.addEventListener("dragstart", (e) => {
          e.dataTransfer.setData("text/plain", note.dataset.duration);
        });
      });

      document.querySelector(".staff-scroll-container").addEventListener("dragover", (e) => {
          e.preventDefault();
      });

      document.querySelectorAll('.accidental-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            // Remove active class from all accidental buttons
            document.querySelectorAll('.accidental-btn').forEach(b => 
                b.classList.remove('active'));
            // Add active class to clicked button
            this.classList.add('active');
        });
      });
    
      document.querySelectorAll('.articulation-btn').forEach(btn => {
          btn.addEventListener('click', function() {
              // Remove active class from all articulation buttons
              document.querySelectorAll('.articulation-btn').forEach(b => 
                  b.classList.remove('active'));
              // Add active class to clicked button
              this.classList.add('active');
          });
      });

      document.getElementById('key-signature').addEventListener('change', function() {
        initializeStaves();
      });
      
      // Initialize everything when the page loads
      document.addEventListener('DOMContentLoaded', function() {
        initializePreviewSystem();
        initializeStaves();
      });
    </script>
  </body>
</html>
